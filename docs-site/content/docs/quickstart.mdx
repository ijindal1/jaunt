---
title: Quickstart
description: "Zero to generated code in 5 minutes (copy-pasteable)."
---

This is the shortest path to an "aha": write one tiny spec, run `jaunt build`, and call real generated code like normal Python.

<Callout type="warning">
  `jaunt build` calls your configured LLM provider (default: OpenAI) and will spend tokens. Set `OPENAI_API_KEY` first.
</Callout>

## Project Layout

Create a small "src layout" project. The `__init__.py` files can be empty:

```text
myproj/
  jaunt.toml
  src/
    my_app/
      __init__.py      # empty
      specs.py          # your @jaunt.magic specs
  tests/
    __init__.py        # empty
    specs_email.py     # your @jaunt.test specs
```

## 1) Install

Jaunt is an MVP and is typically installed from a local checkout.

If you’re working from the Jaunt repo:

```bash
uv sync
export OPENAI_API_KEY=...
uv run jaunt --version
```

If you’re adding Jaunt to your own project, install it however you vend it (local path, internal index, or git). You also need pytest for `jaunt test`:

```bash
# Example (local path):
uv add --editable /path/to/jaunt
uv add pytest
export OPENAI_API_KEY=...
```

## 2) Create `jaunt.toml`

`myproj/jaunt.toml`:

```toml
version = 1

[paths]
source_roots = ["src"]
test_roots = ["tests"]
generated_dir = "__generated__"
```

## 3) Write Your First Spec (`@jaunt.magic`)

`myproj/src/my_app/specs.py`:

```python
from __future__ import annotations

import jaunt


@jaunt.magic()
def normalize_email(raw: str) -> str:
    """
    Normalize an email address for stable comparisons.

    Rules:
    - Strip surrounding whitespace.
    - Lowercase the whole string.
    - Must contain exactly one "@".
    - Local-part and domain must both be non-empty after splitting.

    Errors:
    - Raise ValueError if `raw` is invalid by the rules above.
    """
    raise RuntimeError("spec stub (generated at build time)")
```

This docstring is the contract. The type hints matter. The body is a placeholder.

## 4) Generate Code

From `myproj/`:

```bash
jaunt build
```

Jaunt reads your spec, sends it to OpenAI, validates the output, and writes a real module to:

```text
src/my_app/__generated__/specs.py
```

## 5) Use It (Runtime Forwarding)

You import the spec module. The decorator forwards your call into `__generated__/`.

```bash
PYTHONPATH=src python - <<'PY'
from my_app.specs import normalize_email

print(normalize_email("  A@B.COM  "))  # -> "a@b.com"
PY
```

If you call it before building, you’ll get `jaunt.JauntNotBuiltError` with a hint to run `jaunt build`.

## 6) Add A Test Spec (`@jaunt.test`)

`myproj/tests/specs_email.py`:

```python
from __future__ import annotations

import jaunt


@jaunt.test()
def test_normalize_email__lowercases_and_strips() -> None:
    """
    Assert normalize_email:
    - strips surrounding whitespace
    - lowercases
    - rejects invalid inputs like "no-at-sign" (ValueError)

    Examples:
    - normalize_email("  A@B.COM  ") == "a@b.com"
    """
    raise AssertionError("spec stub (generated at test time)")
```

Now generate tests and run pytest:

```bash
PYTHONPATH=src jaunt test
```

Jaunt writes generated tests under:

- `tests/__generated__/specs_email.py`

## What Next

<Cards>
  <Card title="How It Works" href="/docs/how-it-works" />
  <Card title="Writing Better Specs" href="/docs/writing-specs/tips" />
  <Card title="JWT Walkthrough (Hero Demo)" href="/docs/guides/jwt-walkthrough" />
</Cards>

Next: [How It Works](/docs/how-it-works).
